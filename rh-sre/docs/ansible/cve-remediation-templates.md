---
title: CVE Remediation Playbook Templates
category: ansible
sources:
  - title: Red Hat Lightspeed Remediations Guide
    url: https://docs.redhat.com/en/documentation/red_hat_lightspeed/1-latest/html-single/red_hat_lightspeed_remediations_guide/index
    sections: Creating remediation plans, playbook generation
    date_accessed: 2026-01-20
  - title: Creating and Managing Remediation Plans
    url: https://docs.redhat.com/en/documentation/red_hat_lightspeed/1-latest/html-single/red_hat_lightspeed_remediations_guide/index#creating-remediation-plans_red-hat-lightspeed-remediation-guide
    sections: Playbook templates, execution patterns
    date_accessed: 2026-01-20
  - title: Creating Remediation Playbooks (RHEL 7 Security Guide)
    url: https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/security_guide/creating-a-remediation-ansible-playbook-to-align-the-system-with-baseline_scanning-the-system-for-configuration-compliance-and-vulnerabilities
    sections: Ansible playbook patterns for security compliance
    date_accessed: 2026-01-20
tags: [cve, remediation, playbooks, ansible, templates, package-update, kernel, service-restart, selinux, batch]
applies_to: [rhel7, rhel8, rhel9, openshift4.x]
semantic_keywords:
  - "package update"
  - "kernel update"
  - "service restart"
  - "configuration change"
  - "SELinux context"
  - "batch remediation"
  - "reboot handling"
  - "rollback strategy"
  - "idempotent playbook"
  - "CVE patch"
use_cases:
  - "package_update_cve"
  - "kernel_cve"
  - "service_restart_cve"
  - "config_file_cve"
  - "selinux_cve"
  - "batch_remediation"
related_docs:
  - "rhel/package-management.md"
  - "ansible/error-handling.md"
  - "rhel/version-compatibility.md"
last_updated: 2026-01-20
---

# CVE Remediation Playbook Templates

This document provides 6 production-ready Ansible playbook templates for CVE remediation on RHEL systems. All templates are based on official Red Hat Lightspeed remediation patterns and best practices.

## Overview

Red Hat Lightspeed automatically generates Ansible playbooks for CVE remediation. These templates represent the core patterns used in production environments, enhanced with:

- **Error handling**: Block/rescue/always patterns for safe execution
- **Rollback capability**: Automated rollback on failure
- **Audit logging**: Comprehensive remediation tracking
- **Reboot handling**: Safe reboot detection and execution
- **Idempotency**: Safe to re-run without side effects
- **Health checks**: Pre-flight and post-flight validation

## Template Index

1. **[Template 1: Package Update](#template-1-package-update-most-common)** - Standard package updates (most common)
2. **[Template 2: Service Restart](#template-2-service-restart)** - Service configuration CVEs
3. **[Template 3: Configuration File Update](#template-3-configuration-file-update)** - Config file modifications
4. **[Template 4: Kernel Update with Reboot](#template-4-kernel-update-with-reboot)** - Kernel CVEs requiring reboot
5. **[Template 5: SELinux Context Update](#template-5-selinux-context-update)** - SELinux-related CVEs
6. **[Template 6: Batch Remediation](#template-6-batch-remediation)** - Multiple CVEs across fleet

## When to Use Each Template

| CVE Type | Affected Component | Template | Reboot Required? | K8s Considerations |
|----------|-------------------|----------|------------------|-------------------|
| Package vulnerability | User-space package | Template 1 | Usually no | Service restart if pod |
| Service configuration | Service daemon | Template 2 | No | Pod restart recommended |
| Config file issue | System config | Template 3 | Usually no | ConfigMap update if K8s |
| Kernel vulnerability | Linux kernel | Template 4 | Yes | Node drain required |
| SELinux context | File contexts | Template 5 | No | Rare in containerized |
| Multiple CVEs | Various | Template 6 | Depends | Batch node updates |

---

## Template 1: Package Update (Most Common)

### Use Case
Standard package updates for CVEs affecting user-space packages (httpd, openssl, glibc, etc.). This is the most common CVE remediation pattern.

### When to Use
- CVE affects an installed package
- Fix available via package update (DNF/YUM)
- No kernel or system-critical components involved
- Service restart sufficient (no reboot needed)

### Key Features
- RHEL version validation (7/8/9 compatibility)
- Automatic backup creation (RHEL 8/9 snapshots)
- Package update with cache refresh
- Reboot detection
- Conditional service restarts
- Audit logging
- Idempotent (safe to re-run)

### Complete Playbook

```yaml
---
- name: CVE-YYYY-NNNNN Remediation - Package Update
  hosts: affected_systems
  become: true
  gather_facts: true

  vars:
    cve_id: "CVE-YYYY-NNNNN"
    vulnerable_packages:
      - package-name-1
      - package-name-2
    affected_services: []  # Optional: services to restart after update

  pre_tasks:
    - name: Gather package facts
      package_facts:
        manager: auto

    - name: Verify system is RHEL
      assert:
        that:
          - ansible_distribution == "RedHat"
          - ansible_distribution_major_version in ["7", "8", "9"]
        fail_msg: "This playbook is for Red Hat Enterprise Linux systems only"
        success_msg: "RHEL {{ ansible_distribution_major_version }} detected"

    - name: Check current vulnerable package versions
      debug:
        msg: >
          Package {{ item }} current version:
          {{ ansible_facts.packages[item][0].version | default('not installed') }}
      loop: "{{ vulnerable_packages }}"
      when: item in ansible_facts.packages

    - name: Create backup point (RHEL 8/9 with Boom)
      command: >
        boom create --title "pre-{{ cve_id }}-{{ ansible_date_time.epoch }}"
      when:
        - ansible_distribution_major_version in ["8", "9"]
      ignore_errors: true
      register: backup_result

    - name: Log backup creation
      debug:
        msg: "Backup created: {{ backup_result.stdout | default('skipped or failed') }}"

  tasks:
    - name: Update vulnerable packages
      block:
        - name: Update packages using DNF (RHEL 8/9)
          dnf:
            name: "{{ vulnerable_packages }}"
            state: latest
            update_cache: true
          register: package_update
          when: ansible_distribution_major_version in ["8", "9"]

        - name: Update packages using YUM (RHEL 7)
          yum:
            name: "{{ vulnerable_packages }}"
            state: latest
            update_cache: true
          register: package_update
          when: ansible_distribution_major_version == "7"

        - name: Verify package update success
          assert:
            that:
              - package_update is changed or package_update is success
            fail_msg: "Package update failed"
            success_msg: "Packages updated successfully"

      rescue:
        - name: Log package update failure
          debug:
            msg: "Package update failed: {{ package_update.msg | default('unknown error') }}"

        - name: Fail playbook on update error
          fail:
            msg: "CVE remediation failed - package update error"

    - name: Check if reboot is required
      stat:
        path: /var/run/reboot-required
      register: reboot_required_file

    - name: Check if reboot is required (systemd method)
      command: needs-restarting -r
      register: needs_restarting
      failed_when: false
      changed_when: false
      when: ansible_distribution_major_version in ["8", "9"]

  post_tasks:
    - name: Gather updated package facts
      package_facts:
        manager: auto

    - name: Verify package versions after update
      debug:
        msg: >
          Package {{ item }} updated version:
          {{ ansible_facts.packages[item][0].version | default('not installed') }}
      loop: "{{ vulnerable_packages }}"
      when: item in ansible_facts.packages

    - name: Restart affected services (if no reboot needed)
      systemd:
        name: "{{ item }}"
        state: restarted
      loop: "{{ affected_services | default([]) }}"
      when:
        - affected_services is defined
        - affected_services | length > 0
        - not (reboot_required_file.stat.exists | default(false))
        - needs_restarting.rc == 0 | default(true)

    - name: Wait for services to be active
      systemd:
        name: "{{ item }}"
        state: started
      loop: "{{ affected_services | default([]) }}"
      when:
        - affected_services is defined
        - affected_services | length > 0
        - not (reboot_required_file.stat.exists | default(false))

    - name: Log remediation success
      lineinfile:
        path: /var/log/cve-remediation.log
        line: >
          {{ ansible_date_time.iso8601 }} - {{ cve_id }} remediated -
          {{ package_update.results | length | default(0) }} packages updated on {{ inventory_hostname }}
        create: true
        mode: '0644'

    - name: Notify if reboot required
      debug:
        msg: |
          ⚠️  REBOOT REQUIRED ⚠️
          System: {{ inventory_hostname }}
          Reason: Package update requires reboot
          Action: Schedule maintenance window for reboot
      when: >
        reboot_required_file.stat.exists | default(false) or
        (needs_restarting.rc != 0 | default(false))

    - name: Create reboot notification file
      copy:
        content: |
          CVE: {{ cve_id }}
          Date: {{ ansible_date_time.iso8601 }}
          Packages Updated: {{ vulnerable_packages | join(', ') }}
          Reason: Package update requires system reboot
        dest: "/root/REBOOT_REQUIRED_{{ cve_id }}.txt"
        mode: '0644'
      when: >
        reboot_required_file.stat.exists | default(false) or
        (needs_restarting.rc != 0 | default(false))
```

### Usage Example

```bash
# Create inventory file
cat > inventory.ini <<EOF
[affected_systems]
web-server-01 ansible_host=10.0.1.10
web-server-02 ansible_host=10.0.1.11
EOF

# Create playbook with specific CVE details
cat > remediate-cve-2024-1234.yml <<EOF
---
- name: CVE-2024-1234 Remediation - httpd Package
  hosts: affected_systems
  become: true
  gather_facts: true

  vars:
    cve_id: "CVE-2024-1234"
    vulnerable_packages:
      - httpd
      - httpd-tools
    affected_services:
      - httpd

  # Include the template content above
EOF

# Execute playbook
ansible-playbook -i inventory.ini remediate-cve-2024-1234.yml --check  # Dry run
ansible-playbook -i inventory.ini remediate-cve-2024-1234.yml          # Execute
```

### Pitfalls to Avoid

❌ **Don't skip pre-flight checks**: Always validate RHEL version and package existence
❌ **Don't ignore reboot detection**: Some package updates require reboots
❌ **Don't update without backup**: Create backups on RHEL 8/9 before major changes
❌ **Don't restart services if reboot needed**: Check reboot requirements first
❌ **Don't forget audit logging**: Always log remediation actions for compliance


---

## Template 2: Service Restart

### Use Case
CVEs that require service configuration changes or service restarts without package updates.

### When to Use
- CVE affects service configuration (not the binary)
- Fix involves config file changes only
- Service restart sufficient for remediation
- No package updates required

### Key Features
- Service configuration backup
- Configuration validation before applying
- Graceful service restart with health checks
- Configuration rollback on failure
- Service availability verification

### Complete Playbook

```yaml
---
- name: CVE-YYYY-NNNNN Remediation - Service Configuration
  hosts: affected_systems
  become: true
  gather_facts: true

  vars:
    cve_id: "CVE-YYYY-NNNNN"
    service_name: "httpd"  # Example: httpd, sshd, nginx, etc.
    config_file: "/etc/httpd/conf/httpd.conf"
    config_backup_dir: "/var/backups/cve-remediation"
    health_check_url: "http://localhost:80"  # Optional health check

  pre_tasks:
    - name: Verify service exists
      systemd:
        name: "{{ service_name }}"
      register: service_status
      check_mode: true

    - name: Create backup directory
      file:
        path: "{{ config_backup_dir }}"
        state: directory
        mode: '0755'

    - name: Backup current configuration
      copy:
        src: "{{ config_file }}"
        dest: "{{ config_backup_dir }}/{{ config_file | basename }}.{{ ansible_date_time.epoch }}.bak"
        remote_src: true
        mode: preserve
      register: backup_config

    - name: Record original service state
      service_facts:

    - name: Verify service is running before changes
      assert:
        that:
          - ansible_facts.services[service_name + '.service'].state == 'running'
        fail_msg: "Service {{ service_name }} is not running - cannot proceed"
        success_msg: "Service {{ service_name }} is active"

  tasks:
    - name: Apply configuration changes
      block:
        # IMPORTANT: This section should be customized per CVE
        # Example: Disable vulnerable TLS versions
        - name: Update service configuration
          lineinfile:
            path: "{{ config_file }}"
            regexp: '^#?SSLProtocol.*'
            line: 'SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1'
            backup: true
          register: config_update
          # Add more configuration tasks as needed per CVE

        - name: Validate configuration syntax
          command: "{{ service_name }} -t"  # Most services support -t for test
          register: config_test
          failed_when: config_test.rc != 0
          when: service_name in ['httpd', 'nginx', 'sshd']

        - name: Restart service with configuration reload
          systemd:
            name: "{{ service_name }}"
            state: restarted
            daemon_reload: true
          register: service_restart

        - name: Wait for service to be active
          systemd:
            name: "{{ service_name }}"
            state: started
          retries: 3
          delay: 5

        - name: Health check (if URL provided)
          uri:
            url: "{{ health_check_url }}"
            status_code: 200
            timeout: 10
          register: health_check
          when: health_check_url is defined
          retries: 3
          delay: 5

      rescue:
        - name: Log configuration failure
          debug:
            msg: "Configuration update or service restart failed - initiating rollback"

        - name: Restore configuration from backup
          copy:
            src: "{{ backup_config.dest }}"
            dest: "{{ config_file }}"
            remote_src: true
            mode: preserve

        - name: Restart service with original configuration
          systemd:
            name: "{{ service_name }}"
            state: restarted
            daemon_reload: true

        - name: Fail playbook after rollback
          fail:
            msg: "CVE remediation failed - configuration rolled back to previous state"

  post_tasks:
    - name: Verify service is running after remediation
      service_facts:

    - name: Assert service health
      assert:
        that:
          - ansible_facts.services[service_name + '.service'].state == 'running'
        fail_msg: "Service {{ service_name }} is not running after remediation"
        success_msg: "Service {{ service_name }} successfully restarted"

    - name: Log remediation success
      lineinfile:
        path: /var/log/cve-remediation.log
        line: >
          {{ ansible_date_time.iso8601 }} - {{ cve_id }} remediated -
          {{ service_name }} service configuration updated on {{ inventory_hostname }}
        create: true
        mode: '0644'

    - name: Document configuration changes
      copy:
        content: |
          CVE: {{ cve_id }}
          Date: {{ ansible_date_time.iso8601 }}
          Service: {{ service_name }}
          Configuration File: {{ config_file }}
          Backup Location: {{ backup_config.dest }}
          Status: Remediation successful
        dest: "/root/CVE_REMEDIATION_{{ cve_id }}.txt"
        mode: '0644'
```

### Usage Example

```yaml
# Remediate sshd CVE requiring config changes
- name: CVE-2024-5678 Remediation - SSH Weak Ciphers
  hosts: all_servers
  become: true

  vars:
    cve_id: "CVE-2024-5678"
    service_name: "sshd"
    config_file: "/etc/ssh/sshd_config"

  tasks:
    - name: Disable weak SSH ciphers
      lineinfile:
        path: "{{ config_file }}"
        regexp: '^#?Ciphers.*'
        line: 'Ciphers aes256-gcm@openssh.com,chacha20-poly1305@openssh.com,aes256-ctr'
        backup: true

    - name: Disable weak MACs
      lineinfile:
        path: "{{ config_file }}"
        regexp: '^#?MACs.*'
        line: 'MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com'
        backup: true
```

### Pitfalls to Avoid

❌ **Don't skip configuration validation**: Always test config syntax before restart
❌ **Don't forget backups**: Configuration rollback impossible without backups
❌ **Don't skip health checks**: Verify service functionality after restart
❌ **Don't use `state: reloaded` for critical changes**: Use `state: restarted` for security fixes

---

## Template 3: Configuration File Update

### Use Case
CVEs requiring modifications to system configuration files (not service-specific configs).

### When to Use
- CVE affects system-level configuration (/etc/sysctl.conf, /etc/security/limits.conf, etc.)
- Fix involves file content changes
- No package updates or service restarts required
- Configuration takes effect via sysctl reload or next boot

### Key Features
- Configuration file backup
- Atomic file updates
- Configuration validation
- Sysctl reload for kernel parameters
- Audit trail

### Complete Playbook

```yaml
---
- name: CVE-YYYY-NNNNN Remediation - System Configuration Update
  hosts: affected_systems
  become: true
  gather_facts: true

  vars:
    cve_id: "CVE-YYYY-NNNNN"
    config_file: "/etc/sysctl.conf"  # Example: sysctl, limits, etc.
    config_backup_dir: "/var/backups/cve-remediation"
    sysctl_reload: true  # Set to true if sysctl configuration

  pre_tasks:
    - name: Create backup directory
      file:
        path: "{{ config_backup_dir }}"
        state: directory
        mode: '0755'

    - name: Backup current configuration
      copy:
        src: "{{ config_file }}"
        dest: "{{ config_backup_dir }}/{{ config_file | basename }}.{{ ansible_date_time.epoch }}.bak"
        remote_src: true
        mode: preserve
      register: backup_config

    - name: Record current configuration checksum
      stat:
        path: "{{ config_file }}"
        checksum_algorithm: sha256
      register: original_config_stat

  tasks:
    - name: Update configuration file
      block:
        # Example: Disable source routing (CVE mitigation)
        - name: Set kernel parameter - Disable source routing
          sysctl:
            name: net.ipv4.conf.all.accept_source_route
            value: '0'
            state: present
            reload: "{{ sysctl_reload }}"
            sysctl_file: "{{ config_file }}"
          when: config_file contains 'sysctl'

        - name: Set kernel parameter - Disable ICMP redirects
          sysctl:
            name: net.ipv4.conf.all.accept_redirects
            value: '0'
            state: present
            reload: "{{ sysctl_reload }}"
            sysctl_file: "{{ config_file }}"
          when: config_file contains 'sysctl'

        # For non-sysctl configs, use lineinfile or blockinfile
        - name: Update non-sysctl configuration
          lineinfile:
            path: "{{ config_file }}"
            regexp: '^#?ParameterName.*'
            line: 'ParameterName value'
            backup: true
          when: config_file not contains 'sysctl'
          register: config_update

        - name: Verify configuration change
          stat:
            path: "{{ config_file }}"
            checksum_algorithm: sha256
          register: new_config_stat

        - name: Assert configuration was modified
          assert:
            that:
              - new_config_stat.stat.checksum != original_config_stat.stat.checksum
            fail_msg: "Configuration file was not modified"
            success_msg: "Configuration successfully updated"

      rescue:
        - name: Log configuration failure
          debug:
            msg: "Configuration update failed - initiating rollback"

        - name: Restore configuration from backup
          copy:
            src: "{{ backup_config.dest }}"
            dest: "{{ config_file }}"
            remote_src: true
            mode: preserve

        - name: Reload original sysctl configuration
          command: sysctl -p {{ config_file }}
          when: sysctl_reload and (config_file contains 'sysctl')

        - name: Fail playbook after rollback
          fail:
            msg: "CVE remediation failed - configuration rolled back"

  post_tasks:
    - name: Verify sysctl parameters (if applicable)
      command: sysctl net.ipv4.conf.all.accept_source_route net.ipv4.conf.all.accept_redirects
      register: sysctl_verify
      when: sysctl_reload and (config_file contains 'sysctl')
      changed_when: false

    - name: Display sysctl values
      debug:
        msg: "{{ sysctl_verify.stdout_lines }}"
      when: sysctl_reload and (config_file contains 'sysctl')

    - name: Log remediation success
      lineinfile:
        path: /var/log/cve-remediation.log
        line: >
          {{ ansible_date_time.iso8601 }} - {{ cve_id }} remediated -
          {{ config_file }} updated on {{ inventory_hostname }}
        create: true
        mode: '0644'

    - name: Document configuration changes
      copy:
        content: |
          CVE: {{ cve_id }}
          Date: {{ ansible_date_time.iso8601 }}
          Configuration File: {{ config_file }}
          Backup Location: {{ backup_config.dest }}
          Changes: Kernel parameters hardened per CVE mitigation
          Status: Remediation successful
        dest: "/root/CVE_REMEDIATION_{{ cve_id }}.txt"
        mode: '0644'
```

### Usage Example

```yaml
# Remediate kernel parameter CVE
- name: CVE-2024-9012 Remediation - Kernel Parameter Hardening
  hosts: all_servers
  become: true

  vars:
    cve_id: "CVE-2024-9012"
    config_file: "/etc/sysctl.conf"
    sysctl_reload: true

  tasks:
    - name: Disable IP forwarding
      sysctl:
        name: net.ipv4.ip_forward
        value: '0'
        state: present
        reload: true
        sysctl_file: /etc/sysctl.conf

    - name: Enable SYN cookies
      sysctl:
        name: net.ipv4.tcp_syncookies
        value: '1'
        state: present
        reload: true
        sysctl_file: /etc/sysctl.conf
```

### Pitfalls to Avoid

❌ **Don't skip sysctl reload**: Changes won't take effect until reload or reboot
❌ **Don't modify production configs without backup**: Always create backups
❌ **Don't forget validation**: Verify sysctl values after reload
❌ **Don't use persistent=no for security fixes**: Security parameters should persist across reboots

---

## Template 4: Kernel Update with Reboot

### Use Case
Critical kernel CVEs requiring kernel package updates and system reboots.

### When to Use
- CVE affects the Linux kernel
- Fix available via kernel package update
- System reboot mandatory for remediation
- High-impact operation requiring maintenance window

### Key Features
- Kernel version validation
- Grub configuration backup
- Safe reboot with timeout
- Kubernetes node draining (if applicable)
- Post-reboot verification
- Health checks after reboot

### Complete Playbook

```yaml
---
- name: CVE-YYYY-NNNNN Remediation - Kernel Update with Reboot
  hosts: affected_systems
  become: true
  gather_facts: true
  serial: 1  # Update one host at a time for safety

  vars:
    cve_id: "CVE-YYYY-NNNNN"
    kernel_package: "kernel"
    reboot_timeout: 600  # 10 minutes
    post_reboot_delay: 30  # Wait 30 seconds after reboot
    kubernetes_node: false  # Set to true if K8s node
    drain_timeout: 300  # 5 minutes for node drain

  pre_tasks:
    - name: Record current kernel version
      command: uname -r
      register: current_kernel
      changed_when: false

    - name: Display current kernel
      debug:
        msg: "Current kernel: {{ current_kernel.stdout }}"

    - name: Check if system is a Kubernetes node
      stat:
        path: /etc/kubernetes/kubelet.conf
      register: k8s_check

    - name: Set kubernetes_node fact
      set_fact:
        kubernetes_node: "{{ k8s_check.stat.exists }}"

    - name: Drain Kubernetes node (if applicable)
      command: kubectl drain {{ inventory_hostname }} --ignore-daemonsets --delete-emptydir-data --force --timeout={{ drain_timeout }}s
      delegate_to: localhost
      when: kubernetes_node
      register: drain_result

    - name: Log node drain
      debug:
        msg: "Node drained: {{ drain_result.stdout }}"
      when: kubernetes_node

    - name: Create pre-update snapshot (RHEL 8/9)
      command: >
        boom create --title "pre-kernel-{{ cve_id }}-{{ ansible_date_time.epoch }}"
      when: ansible_distribution_major_version in ["8", "9"]
      ignore_errors: true
      register: snapshot_result

    - name: Backup GRUB configuration
      copy:
        src: /etc/default/grub
        dest: /var/backups/grub.{{ ansible_date_time.epoch }}.bak
        remote_src: true
        mode: preserve

  tasks:
    - name: Update kernel package
      block:
        - name: Update kernel using DNF (RHEL 8/9)
          dnf:
            name: "{{ kernel_package }}"
            state: latest
            update_cache: true
          register: kernel_update
          when: ansible_distribution_major_version in ["8", "9"]

        - name: Update kernel using YUM (RHEL 7)
          yum:
            name: "{{ kernel_package }}"
            state: latest
            update_cache: true
          register: kernel_update
          when: ansible_distribution_major_version == "7"

        - name: Verify kernel update
          assert:
            that:
              - kernel_update is changed or kernel_update is success
            fail_msg: "Kernel update failed"
            success_msg: "Kernel updated successfully"

      rescue:
        - name: Log kernel update failure
          debug:
            msg: "Kernel update failed: {{ kernel_update.msg | default('unknown error') }}"

        - name: Uncordon Kubernetes node on failure
          command: kubectl uncordon {{ inventory_hostname }}
          delegate_to: localhost
          when: kubernetes_node
          ignore_errors: true

        - name: Fail playbook
          fail:
            msg: "CVE remediation failed - kernel update error"

    - name: Create reboot notification
      copy:
        content: |
          CVE: {{ cve_id }}
          Date: {{ ansible_date_time.iso8601 }}
          System: {{ inventory_hostname }}
          Current Kernel: {{ current_kernel.stdout }}
          Action: System will reboot to apply kernel update
        dest: "/root/REBOOTING_FOR_{{ cve_id }}.txt"
        mode: '0644'

    - name: Log pre-reboot state
      lineinfile:
        path: /var/log/cve-remediation.log
        line: >
          {{ ansible_date_time.iso8601 }} - {{ cve_id }} - Pre-reboot -
          Current kernel: {{ current_kernel.stdout }} - {{ inventory_hostname }}
        create: true
        mode: '0644'

    - name: Reboot system to apply kernel update
      reboot:
        reboot_timeout: "{{ reboot_timeout }}"
        post_reboot_delay: "{{ post_reboot_delay }}"
        msg: "Rebooting for CVE-{{ cve_id }} kernel update"
      register: reboot_result

  post_tasks:
    - name: Verify system is back online
      wait_for_connection:
        timeout: 300

    - name: Gather facts after reboot
      setup:

    - name: Record new kernel version
      command: uname -r
      register: new_kernel
      changed_when: false

    - name: Verify kernel was updated
      assert:
        that:
          - new_kernel.stdout != current_kernel.stdout
        fail_msg: "Kernel was not updated - still running {{ current_kernel.stdout }}"
        success_msg: "Kernel updated from {{ current_kernel.stdout }} to {{ new_kernel.stdout }}"

    - name: Verify all services are running
      service_facts:

    - name: Check critical services
      assert:
        that:
          - ansible_facts.services['sshd.service'].state == 'running'
        fail_msg: "Critical services not running after reboot"
        success_msg: "System health check passed"

    - name: Uncordon Kubernetes node
      command: kubectl uncordon {{ inventory_hostname }}
      delegate_to: localhost
      when: kubernetes_node
      register: uncordon_result

    - name: Wait for node to be ready
      command: kubectl wait --for=condition=Ready node/{{ inventory_hostname }} --timeout=300s
      delegate_to: localhost
      when: kubernetes_node

    - name: Log remediation success
      lineinfile:
        path: /var/log/cve-remediation.log
        line: >
          {{ ansible_date_time.iso8601 }} - {{ cve_id }} remediated -
          Kernel updated from {{ current_kernel.stdout }} to {{ new_kernel.stdout }} on {{ inventory_hostname }}
        create: true
        mode: '0644'

    - name: Document kernel update
      copy:
        content: |
          CVE: {{ cve_id }}
          Date: {{ ansible_date_time.iso8601 }}
          System: {{ inventory_hostname }}
          Previous Kernel: {{ current_kernel.stdout }}
          New Kernel: {{ new_kernel.stdout }}
          Reboot Duration: {{ reboot_result.elapsed }} seconds
          Kubernetes Node: {{ kubernetes_node }}
          Status: Remediation successful
        dest: "/root/CVE_REMEDIATION_{{ cve_id }}.txt"
        mode: '0644'

    - name: Clean up notification files
      file:
        path: "/root/REBOOTING_FOR_{{ cve_id }}.txt"
        state: absent
```

### Usage Example

```bash
# Kernel CVE remediation with Kubernetes integration
ansible-playbook -i k8s-nodes.ini remediate-kernel-cve.yml \
  --extra-vars "cve_id=CVE-2024-3456 kubernetes_node=true" \
  --limit production-worker-nodes \
  --ask-become-pass

# Serial execution (one node at a time) is built into the playbook
# with 'serial: 1' directive
```

### Kubernetes/OpenShift Considerations

**Before running this playbook on K8s nodes**:

1. **Review pod disruption budgets**: Ensure critical apps can tolerate node drain
2. **Check StatefulSets**: May require special handling
3. **Verify cluster capacity**: Ensure remaining nodes can handle workload
4. **Schedule maintenance window**: Kernel updates are high-impact

### Pitfalls to Avoid

❌ **Don't reboot all nodes simultaneously**: Use `serial: 1` for safety
❌ **Don't forget post-reboot verification**: Ensure new kernel is running
❌ **Don't set short reboot timeouts**: Kernel updates can take 5-10 minutes

---

## Template 5: SELinux Context Update

### Use Case
CVEs affecting SELinux file contexts or requiring SELinux policy updates.

### When to Use
- CVE involves SELinux context issues
- Fix requires `restorecon` or policy updates
- SELinux denials blocking remediation
- No package updates required (context-only fixes)

### Key Features
- SELinux status validation
- Context backup
- Safe context restoration
- Policy module management
- AVC denial checking
- Rollback capability

### Complete Playbook

```yaml
---
- name: CVE-YYYY-NNNNN Remediation - SELinux Context Update
  hosts: affected_systems
  become: true
  gather_facts: true

  vars:
    cve_id: "CVE-YYYY-NNNNN"
    affected_paths:
      - /path/to/affected/file1
      - /path/to/affected/dir/
    selinux_type: "httpd_sys_content_t"  # Example context
    backup_dir: "/var/backups/selinux-contexts"

  pre_tasks:
    - name: Check SELinux status
      command: getenforce
      register: selinux_status
      changed_when: false
      failed_when: selinux_status.stdout not in ['Enforcing', 'Permissive']

    - name: Verify SELinux is not disabled
      assert:
        that:
          - selinux_status.stdout != 'Disabled'
        fail_msg: "SELinux is disabled - this playbook requires SELinux to be enabled"
        success_msg: "SELinux mode: {{ selinux_status.stdout }}"

    - name: Create backup directory
      file:
        path: "{{ backup_dir }}"
        state: directory
        mode: '0755'

    - name: Backup current SELinux contexts
      shell: >
        ls -Z {{ item }} > {{ backup_dir }}/{{ item | basename }}.{{ ansible_date_time.epoch }}.context
      loop: "{{ affected_paths }}"
      changed_when: false

    - name: Check for recent AVC denials
      command: ausearch -m avc -ts recent
      register: avc_denials
      failed_when: false
      changed_when: false

    - name: Log AVC denials if present
      debug:
        msg: "Recent AVC denials detected - review /var/log/audit/audit.log"
      when: avc_denials.rc == 0

  tasks:
    - name: Apply SELinux context fixes
      block:
        - name: Restore default SELinux contexts
          command: restorecon -Rv {{ item }}
          loop: "{{ affected_paths }}"
          register: restorecon_result

        - name: Set specific SELinux type (if needed)
          sefcontext:
            target: '{{ item }}(/.*)?'
            setype: "{{ selinux_type }}"
            state: present
          loop: "{{ affected_paths }}"
          when: selinux_type is defined
          register: sefcontext_result

        - name: Apply new context after semanage
          command: restorecon -Rv {{ item }}
          loop: "{{ affected_paths }}"
          when: sefcontext_result is changed

        - name: Verify contexts were applied
          shell: ls -Z {{ item }}
          loop: "{{ affected_paths }}"
          register: context_verify
          changed_when: false

        - name: Display new contexts
          debug:
            msg: "{{ context_verify.results | map(attribute='stdout_lines') | list }}"

      rescue:
        - name: Log SELinux context failure
          debug:
            msg: "SELinux context update failed - review AVC denials"

        - name: Display backup location
          debug:
            msg: "Context backups available in {{ backup_dir }}"

        - name: Fail playbook
          fail:
            msg: "CVE remediation failed - SELinux context update error"

  post_tasks:
    - name: Check for new AVC denials
      command: ausearch -m avc -ts recent
      register: new_avc_denials
      failed_when: false
      changed_when: false

    - name: Warn if new AVC denials
      debug:
        msg: "⚠️  New AVC denials detected - manual review required"
      when: new_avc_denials.rc == 0

    - name: Verify SELinux is still enforcing
      command: getenforce
      register: final_selinux_status
      changed_when: false

    - name: Assert SELinux mode unchanged
      assert:
        that:
          - final_selinux_status.stdout == selinux_status.stdout
        fail_msg: "SELinux mode changed unexpectedly"
        success_msg: "SELinux mode stable: {{ final_selinux_status.stdout }}"

    - name: Log remediation success
      lineinfile:
        path: /var/log/cve-remediation.log
        line: >
          {{ ansible_date_time.iso8601 }} - {{ cve_id }} remediated -
          SELinux contexts updated for {{ affected_paths | length }} paths on {{ inventory_hostname }}
        create: true
        mode: '0644'

    - name: Document SELinux changes
      copy:
        content: |
          CVE: {{ cve_id }}
          Date: {{ ansible_date_time.iso8601 }}
          System: {{ inventory_hostname }}
          Affected Paths: {{ affected_paths | join(', ') }}
          SELinux Type Applied: {{ selinux_type | default('default') }}
          Backup Location: {{ backup_dir }}
          Status: Remediation successful
        dest: "/root/CVE_REMEDIATION_{{ cve_id }}.txt"
        mode: '0644'
```

### Usage Example

```yaml
# Remediate httpd SELinux context CVE
- name: CVE-2024-7890 Remediation - httpd SELinux Context
  hosts: web_servers
  become: true

  vars:
    cve_id: "CVE-2024-7890"
    affected_paths:
      - /var/www/html
      - /var/www/cgi-bin
    selinux_type: "httpd_sys_content_t"

  tasks:
    - name: Restore default contexts for web content
      command: restorecon -Rv {{ item }}
      loop: "{{ affected_paths }}"

    - name: Allow httpd network connections (if needed)
      seboolean:
        name: httpd_can_network_connect
        state: true
        persistent: true
```

### Pitfalls to Avoid

❌ **Don't disable SELinux as a "fix"**: This defeats security
❌ **Don't use `setenforce 0`**: Keep SELinux enforcing
❌ **Don't skip AVC denial review**: Understand why denials occurred
❌ **Don't forget `restorecon -R`**: Recursive is critical for directories
❌ **Don't use `-F` flag casually**: Forces relabeling, may have side effects

---

## Template 6: Batch Remediation

### Use Case
Remediating multiple CVEs across a fleet of systems efficiently.

### When to Use
- Multiple CVEs need remediation
- Large number of affected systems
- Want to minimize maintenance windows
- Need comprehensive remediation reporting

### Key Features
- Multi-CVE handling
- Consolidated package updates
- Batch service restarts
- Progress tracking
- Detailed reporting
- Failure isolation (continues on non-critical errors)

### Complete Playbook

```yaml
---
- name: Batch CVE Remediation - Multiple CVEs
  hosts: affected_systems
  become: true
  gather_facts: true
  serial: "{{ batch_size | default(5) }}"  # Configurable batch size

  vars:
    batch_id: "batch-{{ ansible_date_time.epoch }}"
    batch_size: 5  # Process 5 systems concurrently

    cves:
      - cve_id: "CVE-2024-1111"
        packages: ["httpd", "httpd-tools"]
        services: ["httpd"]
        priority: "critical"

      - cve_id: "CVE-2024-2222"
        packages: ["openssl", "openssl-libs"]
        services: []
        priority: "important"

      - cve_id: "CVE-2024-3333"
        packages: ["glibc", "glibc-common"]
        services: []
        priority: "important"

    all_packages: "{{ cves | map(attribute='packages') | flatten | unique | list }}"
    all_services: "{{ cves | map(attribute='services') | flatten | unique | select | list }}"

    report_dir: "/var/log/cve-remediation/{{ batch_id }}"

  pre_tasks:
    - name: Create report directory
      file:
        path: "{{ report_dir }}"
        state: directory
        mode: '0755'

    - name: Log batch remediation start
      copy:
        content: |
          Batch ID: {{ batch_id }}
          Start Time: {{ ansible_date_time.iso8601 }}
          System: {{ inventory_hostname }}
          CVEs to Remediate: {{ cves | map(attribute='cve_id') | join(', ') }}
          Total Packages: {{ all_packages | length }}
          Total Services: {{ all_services | length }}
        dest: "{{ report_dir }}/{{ inventory_hostname }}_start.txt"
        mode: '0644'

    - name: Gather current package versions
      package_facts:
        manager: auto

    - name: Record pre-update package versions
      copy:
        content: |
          {% for pkg in all_packages %}
          {% if pkg in ansible_facts.packages %}
          {{ pkg }}: {{ ansible_facts.packages[pkg][0].version }}
          {% else %}
          {{ pkg }}: not installed
          {% endif %}
          {% endfor %}
        dest: "{{ report_dir }}/{{ inventory_hostname }}_pre_versions.txt"
        mode: '0644'

    - name: Create backup snapshot (RHEL 8/9)
      command: >
        boom create --title "batch-{{ batch_id }}"
      when: ansible_distribution_major_version in ["8", "9"]
      ignore_errors: true

  tasks:
    - name: Batch update all vulnerable packages
      block:
        - name: Update all packages in one transaction (RHEL 8/9)
          dnf:
            name: "{{ all_packages }}"
            state: latest
            update_cache: true
          register: package_update
          when: ansible_distribution_major_version in ["8", "9"]

        - name: Update all packages in one transaction (RHEL 7)
          yum:
            name: "{{ all_packages }}"
            state: latest
            update_cache: true
          register: package_update
          when: ansible_distribution_major_version == "7"

        - name: Verify package updates
          package_facts:
            manager: auto

        - name: Record post-update package versions
          copy:
            content: |
              {% for pkg in all_packages %}
              {% if pkg in ansible_facts.packages %}
              {{ pkg }}: {{ ansible_facts.packages[pkg][0].version }}
              {% else %}
              {{ pkg }}: not installed
              {% endif %}
              {% endfor %}
            dest: "{{ report_dir }}/{{ inventory_hostname }}_post_versions.txt"
            mode: '0644'

      rescue:
        - name: Log package update failures
          copy:
            content: |
              Batch ID: {{ batch_id }}
              System: {{ inventory_hostname }}
              Status: FAILED
              Error: {{ package_update.msg | default('Package update failed') }}
              Failed Packages: {{ package_update.failures | default([]) | join(', ') }}
            dest: "{{ report_dir }}/{{ inventory_hostname }}_FAILED.txt"
            mode: '0644'

        - name: Continue despite package failures
          debug:
            msg: "Package updates failed on {{ inventory_hostname }} - see {{ report_dir }}/{{ inventory_hostname }}_FAILED.txt"

    - name: Check if reboot required
      stat:
        path: /var/run/reboot-required
      register: reboot_required_file

    - name: Check needs-restarting (RHEL 8/9)
      command: needs-restarting -r
      register: needs_restarting
      failed_when: false
      changed_when: false
      when: ansible_distribution_major_version in ["8", "9"]

  post_tasks:
    - name: Restart affected services (if no reboot needed)
      systemd:
        name: "{{ item }}"
        state: restarted
      loop: "{{ all_services }}"
      when:
        - all_services | length > 0
        - not (reboot_required_file.stat.exists | default(false))
        - (needs_restarting.rc == 0) | default(true)
      ignore_errors: true
      register: service_restarts

    - name: Log service restart failures
      copy:
        content: |
          {% for result in service_restarts.results | default([]) %}
          {% if result.failed %}
          Service: {{ result.item }}
          Status: FAILED
          Error: {{ result.msg | default('Unknown error') }}
          {% endif %}
          {% endfor %}
        dest: "{{ report_dir }}/{{ inventory_hostname }}_service_failures.txt"
        mode: '0644'
      when: service_restarts.failed | default(false)

    - name: Generate CVE remediation summary
      copy:
        content: |
          ========================================
          BATCH CVE REMEDIATION SUMMARY
          ========================================
          Batch ID: {{ batch_id }}
          System: {{ inventory_hostname }}
          Completion Time: {{ ansible_date_time.iso8601 }}

          CVEs Remediated:
          {% for cve in cves %}
            - {{ cve.cve_id }} ({{ cve.priority }})
              Packages: {{ cve.packages | join(', ') }}
              Services: {{ cve.services | join(', ') if cve.services else 'None' }}
          {% endfor %}

          Package Updates: {{ all_packages | length }} packages
          Service Restarts: {{ all_services | length }} services

          Reboot Required: {{ 'YES' if (reboot_required_file.stat.exists or (needs_restarting.rc != 0 | default(false))) else 'NO' }}

          {% if reboot_required_file.stat.exists or (needs_restarting.rc != 0 | default(false)) %}
          ⚠️  REBOOT REQUIRED ⚠️
          Schedule maintenance window to reboot this system.
          {% endif %}

          Status: {{ 'SUCCESS' if not (package_update.failed | default(false)) else 'PARTIAL' }}

          Reports Location: {{ report_dir }}
        dest: "{{ report_dir }}/{{ inventory_hostname }}_SUMMARY.txt"
        mode: '0644'

    - name: Log to central remediation log
      lineinfile:
        path: /var/log/cve-remediation.log
        line: >
          {{ ansible_date_time.iso8601 }} - Batch {{ batch_id }} -
          Remediated {{ cves | length }} CVEs -
          {{ all_packages | length }} packages updated -
          {{ 'REBOOT REQUIRED' if (reboot_required_file.stat.exists or (needs_restarting.rc != 0 | default(false))) else 'No reboot' }} -
          {{ inventory_hostname }}
        create: true
        mode: '0644'

    - name: Display remediation summary
      debug:
        msg: "{{ lookup('file', report_dir + '/' + inventory_hostname + '_SUMMARY.txt') }}"
```

### Usage Example

```bash
# Remediate multiple CVEs across production fleet
ansible-playbook -i production-inventory.ini batch-remediation.yml \
  --extra-vars "batch_size=10" \
  --limit web_servers

# Generate consolidated report
grep "Batch batch-" /var/log/cve-remediation.log | \
  awk '{print $1, $2, $NF}' | \
  sort > batch-remediation-summary.txt
```

### Reporting

After execution, find detailed reports in `/var/log/cve-remediation/<batch_id>/`:

```
<batch_id>/
├── host1_start.txt          # Remediation start details
├── host1_pre_versions.txt   # Package versions before update
├── host1_post_versions.txt  # Package versions after update
├── host1_SUMMARY.txt         # Remediation summary
├── host1_FAILED.txt          # Failures (if any)
└── host1_service_failures.txt # Service restart failures (if any)
```

### Pitfalls to Avoid

❌ **Don't set batch_size too high**: Limits blast radius if failures occur
❌ **Don't skip pre/post version recording**: Critical for audit trail
❌ **Don't fail entire batch on single package error**: Use `ignore_errors` strategically
❌ **Don't batch kernel updates**: Kernel CVEs require serial execution (Template 4)
❌ **Don't forget consolidated reporting**: Management needs overall status

---

## Cross-Reference Guide

### For RHEL-Specific Operations
- **[package-management.md](../rhel/package-management.md)** - DNF/YUM workflows, reboot detection
- **[version-compatibility.md](../rhel/version-compatibility.md)** - RHEL 7/8/9 differences
- **[selinux-context.md](../rhel/selinux-context.md)** - SELinux remediation patterns
- **[systemd-services.md](../rhel/systemd-services.md)** - Service management patterns

### For Error Handling & Rollback
- **[error-handling.md](./error-handling.md)** - Block/rescue/always patterns, rollback strategies
- **[idempotency.md](./idempotency.md)** - Safe re-run patterns

### For Execution & Deployment
- **[aap-integration.md](./aap-integration.md)** - Ansible Automation Platform workflows

### For Risk Assessment
- **[vulnerability-logic.md](../insights/vulnerability-logic.md)** - Red Hat Lightspeed risk methodology
- **[cvss-scoring.md](../references/cvss-scoring.md)** - CVSS interpretation

---

## Official Red Hat Sources

This document is derived from:

1. **Red Hat Lightspeed Remediations Guide**
   https://docs.redhat.com/en/documentation/red_hat_insights/1-latest/html-single/red_hat_insights_remediations_guide/index

2. **Creating and Managing Remediation Plans**
   https://docs.redhat.com/en/documentation/red_hat_insights/1-latest/html/red_hat_insights_remediations_guide/creating-managing-playbooks_red-hat-insights-remediation-guide

3. **Creating Remediation Playbooks (RHEL 7 Security Guide)**
   https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/security_guide/creating-a-remediation-ansible-playbook-to-align-the-system-with-baseline_scanning-the-system-for-configuration-compliance-and-vulnerabilities

**License**: Content derived from Red Hat documentation under CC BY-SA 4.0
**Last Verified**: 2026-01-20

---

## Quick Reference Table

| Template | Use Case | Reboot? | K8s Impact | Priority | Complexity |
|----------|----------|---------|------------|----------|------------|
| 1. Package Update | User-space packages | Rare | Low | High | Low |
| 2. Service Restart | Service configs | No | Medium | Medium | Low |
| 3. Config Update | System configs | No | Low | Medium | Low |
| 4. Kernel Update | Kernel CVEs | Yes | High | Critical | High |
| 5. SELinux Context | SELinux issues | No | Low | Medium | Medium |
| 6. Batch Remediation | Multiple CVEs | Varies | Varies | High | High |

## Template Selection Decision Tree

```
Is CVE affecting kernel?
├─ YES → Use Template 4 (Kernel Update)
└─ NO → Is CVE affecting multiple systems?
    ├─ YES → Use Template 6 (Batch Remediation)
    └─ NO → What component is affected?
        ├─ Package → Use Template 1 (Package Update)
        ├─ Service config → Use Template 2 (Service Restart)
        ├─ System config → Use Template 3 (Config Update)
        └─ SELinux context → Use Template 5 (SELinux)
```

---

**Document Version**: 1.0
**Last Updated**: 2026-01-20
**Maintained By**: Remediation Agent Knowledge Base
**Official Sources**: See SOURCES.md for complete attribution
